<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>思维导图： | CCNU物联网协会</title>
    <meta name="description" content="华中师范大学物联网协会">
    <link rel="stylesheet" href="/assets/style.f6382235.css">
    <link rel="modulepreload" href="/assets/app.9eab122d.js">
    <link rel="modulepreload" href="/assets/hardware_group_计算机组成与设计_计算机的语言.md.c8e1d064.lean.js">
    
    <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-6b5fd0a9><!--[--><!--]--><!--[--><span tabindex="-1" data-v-45f6ae50></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-45f6ae50> Skip to content </a><!--]--><!----><header class="VPNav" data-v-6b5fd0a9 data-v-0e356168><div class="VPNavBar has-sidebar" data-v-0e356168 data-v-8856f192><div class="container" data-v-8856f192><div class="VPNavBarTitle has-sidebar" data-v-8856f192 data-v-6a6f7ff6><a class="title" href="/" data-v-6a6f7ff6><!----><!--[-->CCNU物联网协会<!--]--></a></div><div class="content" data-v-8856f192><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8856f192 data-v-a30758ee><span id="main-nav-aria-label" class="visually-hidden" data-v-a30758ee>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Introduction/" data-v-a30758ee data-v-8fba5fa8 data-v-5704c677><!--[-->协会成员<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/hardware_group/" data-v-a30758ee data-v-8fba5fa8 data-v-5704c677><!--[-->硬件组<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/software_group/" data-v-a30758ee data-v-8fba5fa8 data-v-5704c677><!--[-->软件组<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/app_group/" data-v-a30758ee data-v-8fba5fa8 data-v-5704c677><!--[-->APP组<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8856f192 data-v-311055f2><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-311055f2 data-v-781f9d1b data-v-1dda4c9c><span class="check" data-v-1dda4c9c><span class="icon" data-v-1dda4c9c><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-781f9d1b><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-781f9d1b><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8856f192 data-v-0ae890f7 data-v-4dcbaf3a><!--[--><a class="VPSocialLink" href="https://github.com/Nick-JY" title="github" target="_blank" rel="noopener noreferrer" data-v-4dcbaf3a data-v-48c45ef6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-48c45ef6><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-48c45ef6>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8856f192 data-v-0562f5c0 data-v-8dccea88><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-8dccea88><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-8dccea88><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-8dccea88><div class="VPMenu" data-v-8dccea88 data-v-e73581a2><!----><!--[--><!--[--><!----><div class="group" data-v-0562f5c0><div class="item appearance" data-v-0562f5c0><p class="label" data-v-0562f5c0>Appearance</p><div class="appearance-action" data-v-0562f5c0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-0562f5c0 data-v-781f9d1b data-v-1dda4c9c><span class="check" data-v-1dda4c9c><span class="icon" data-v-1dda4c9c><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-781f9d1b><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-781f9d1b><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-0562f5c0><div class="item social-links" data-v-0562f5c0><div class="VPSocialLinks social-links-list" data-v-0562f5c0 data-v-4dcbaf3a><!--[--><a class="VPSocialLink" href="https://github.com/Nick-JY" title="github" target="_blank" rel="noopener noreferrer" data-v-4dcbaf3a data-v-48c45ef6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-48c45ef6><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-48c45ef6>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8856f192 data-v-6f008456><span class="container" data-v-6f008456><span class="top" data-v-6f008456></span><span class="middle" data-v-6f008456></span><span class="bottom" data-v-6f008456></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-6b5fd0a9 data-v-92b0f14a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-92b0f14a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-92b0f14a><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-92b0f14a>Menu</span></button><a class="top-link" href="#" data-v-92b0f14a> Return to top </a></div><aside class="VPSidebar" data-v-6b5fd0a9 data-v-55e4c7db><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-55e4c7db><span class="visually-hidden" id="sidebar-aria-label" data-v-55e4c7db> Sidebar Navigation </span><!--[--><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>硬件组培训</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><a class="VPLink link" href="/hardware_group/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9F%B9%E8%AE%AD/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>Linux虚拟机的安装和卸载</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9F%B9%E8%AE%AD/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>Git快速入门</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>计算机组成与设计:硬软接口</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><a class="VPLink link" href="/hardware_group/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A6%82%E8%A6%81.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>计算机硬件概要</span><!--]--><!----></a><a class="VPLink link active" href="/hardware_group/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%AF%AD%E8%A8%80.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>计算机的语言:指令</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>计算机的算术运算</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/MIPS%E6%9E%B6%E6%9E%84%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>MIPS架构处理器设计</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>51单片机</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%BC%80%E5%8F%91%E6%9D%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>开发板注意事项</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8E%9F%E7%90%86%E5%9B%BE.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>开发板原理图</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/b.LED%E7%81%AF%E7%82%B9%E4%BA%AE%E4%BB%A5%E5%8F%8A%E5%BB%B6%E6%97%B6.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>LED灯点亮以及延时</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/c.%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E6%93%8D%E6%8E%A7LED%E5%BC%80%E5%85%B3%E5%92%8C%E8%9C%82%E9%B8%A3%E5%99%A8%E5%BC%80%E5%85%B3.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>独立按键操控LED灯和蜂鸣器</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/d.%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED%E6%B5%81%E6%B0%B4%E7%81%AF.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>独立按键控制LED流水灯</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/e.%E9%9D%99%E6%80%81%E7%82%B9%E4%BA%AE%E6%95%B0%E7%A0%81%E7%AE%A1.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>静态点亮数码管</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/f.%E5%8A%A8%E6%80%81%E7%82%B9%E4%BA%AE%E6%95%B0%E7%A0%81%E7%AE%A1.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>动态点亮数码管</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/g.%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>矩阵键盘</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/h.%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>外部中断</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/i.%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E8%AE%A1%E6%95%B0%E5%99%A8.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>定时器</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/j.PWM%E8%84%89%E5%AE%BD%E8%B0%83%E5%88%B6%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E6%8E%A7%E5%88%B6.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>PWM脉宽调制信号</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/k.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>UART串口通信</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/l.DS18B20%E6%95%B0%E5%AD%97%E6%B8%A9%E5%BA%A6%E8%AE%A1.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>DS18B20数字温度计</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/m.DS1302%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>DS1302实时时钟</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/n.AT24C02.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>AT24C02-EEPROM</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/o.PCF8591.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>PCF8591-ADC/DAC</span><!--]--><!----></a><a class="VPLink link" href="/hardware_group/51%E5%8D%95%E7%89%87%E6%9C%BA/p.%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E6%A8%A1%E5%9D%97.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>超声波测距模块</span><!--]--><!----></a><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-6b5fd0a9 data-v-a4c57a06><div class="VPDoc has-sidebar" data-v-a4c57a06 data-v-79ca2460><div class="container" data-v-79ca2460><div class="aside" data-v-79ca2460><div class="aside-curtain" data-v-79ca2460></div><div class="aside-container" data-v-79ca2460><div class="aside-content" data-v-79ca2460><div class="VPDocAside" data-v-79ca2460 data-v-779d834d><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-779d834d data-v-51e5a8ce><div class="content" data-v-51e5a8ce><div class="outline-marker" data-v-51e5a8ce></div><div class="outline-title" data-v-51e5a8ce>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-51e5a8ce><span class="visually-hidden" id="doc-outline-aria-label" data-v-51e5a8ce> Table of Contents for current page </span><ul class="root" data-v-51e5a8ce><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-779d834d></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-79ca2460><div class="content-container" data-v-79ca2460><!--[--><!--]--><main class="main" data-v-79ca2460><div style="position:relative;" class="vp-doc _hardware_group_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%AF%AD%E8%A8%80" data-v-79ca2460><div><h3 id="思维导图：" tabindex="-1">思维导图： <a class="header-anchor" href="#思维导图：" aria-hidden="true">#</a></h3><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E4%BB%A4_%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt=""></p><h3 id="一、计算机的语言：指令" tabindex="-1">一、计算机的语言：指令 <a class="header-anchor" href="#一、计算机的语言：指令" aria-hidden="true">#</a></h3><h5 id="_1-指令：" tabindex="-1">1.指令： <a class="header-anchor" href="#_1-指令：" aria-hidden="true">#</a></h5><ul><li>处理器能够通过高低电平的驱动进行工作，二进制数可以转化成相应的高低电平，因此处理器能够读懂二进制数。</li><li>我们所说的指令有两种表现形式，一种是抽象成汇编语言，另一种是纯二进制的机器码，两者是一一对应的，由于处理器能够读懂二进制数，因此也能够读懂指令。</li></ul><h5 id="_2-接口：" tabindex="-1">2.接口： <a class="header-anchor" href="#_2-接口：" aria-hidden="true">#</a></h5><ul><li>我们可以把指令当做计算机软硬件之间的接口，计算机硬件通过指令来与上层软件进行互动。</li></ul><h3 id="二、mips-32寄存器：" tabindex="-1">二、MIPS-32寄存器： <a class="header-anchor" href="#二、mips-32寄存器：" aria-hidden="true">#</a></h3><h4 id="_1-通用寄存器：" tabindex="-1">1.通用寄存器： <a class="header-anchor" href="#_1-通用寄存器：" aria-hidden="true">#</a></h4><ul><li>我们知道寄存器是CPU中存储小数据的一个存储器，因此CPU在读取寄存器数据的时候异常的快。</li><li>通用寄存器指的是可以存储任何二进制数的寄存器，这个数可以是某个存储单元的地址，也可以是某一条指令，也可以是某个数据。</li></ul><h5 id="a-通用寄存器数量" tabindex="-1">a.通用寄存器数量: <a class="header-anchor" href="#a-通用寄存器数量" aria-hidden="true">#</a></h5><ul><li>在MIPS-32中，通用寄存器的数量为32个，并且每个寄存器都是32位。</li><li>32个寄存器能够使MIPS-32架构具有更高的性能。</li></ul><h5 id="b-通用寄存器的分类：" tabindex="-1">b.通用寄存器的分类： <a class="header-anchor" href="#b-通用寄存器的分类：" aria-hidden="true">#</a></h5><h6 id="零寄存器：" tabindex="-1">零寄存器： <a class="header-anchor" href="#零寄存器：" aria-hidden="true">#</a></h6><ul><li>$zero，寄存器编号为0，该寄存器永久存放0，规定不能进行更改。</li></ul><h6 id="临时寄存器：" tabindex="-1">临时寄存器： <a class="header-anchor" href="#临时寄存器：" aria-hidden="true">#</a></h6><ul><li>$t0 ~ $t7，寄存器 $t0的编号是8，这类寄存器主要用来存放过程(c语言中的函数)中创建的临时变量的值，使用后不需要恢复临时寄存器原有的值。</li></ul><h6 id="保留寄存器：" tabindex="-1">保留寄存器： <a class="header-anchor" href="#保留寄存器：" aria-hidden="true">#</a></h6><ul><li>$s0 ~ $s7，寄存器 $s0的编号是16，这类寄存器用来存放主函数中变量的值，如果在过程中需要使用保留寄存器，需要把保留寄存器的值换出到栈，使用完之后在把栈中存储的值存回保留寄存器。</li></ul><h6 id="额外的临时寄存器：" tabindex="-1">额外的临时寄存器： <a class="header-anchor" href="#额外的临时寄存器：" aria-hidden="true">#</a></h6><ul><li>$t8 ~ $t9。</li></ul><h6 id="全局指针：" tabindex="-1">全局指针： <a class="header-anchor" href="#全局指针：" aria-hidden="true">#</a></h6><ul><li>$gp，存储的是存储区中静态区的某个地址，通过偏移来访问整个静态区。在C语言中，全局变量和static声明的变量都存放到存储区中的静态区。</li></ul><h6 id="栈指针：" tabindex="-1">栈指针： <a class="header-anchor" href="#栈指针：" aria-hidden="true">#</a></h6><ul><li>$sp，存储的是栈顶的地址，栈指针指向当前创建的栈区的顶端。</li></ul><h6 id="帧指针：" tabindex="-1">帧指针： <a class="header-anchor" href="#帧指针：" aria-hidden="true">#</a></h6><ul><li>$fp，存储的是栈底的地址，帧指针指向当前创建的栈区的底部。</li></ul><h6 id="返回地址寄存器：" tabindex="-1">返回地址寄存器： <a class="header-anchor" href="#返回地址寄存器：" aria-hidden="true">#</a></h6><ul><li>$ra，用来存储某个过程的返回地址。(C语言在调用函数结束后要返回主函数)</li></ul><h3 id="三、内存分区：" tabindex="-1">三、内存分区： <a class="header-anchor" href="#三、内存分区：" aria-hidden="true">#</a></h3><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt=""></p><ul><li>一般来讲，堆区和栈区是相互生长的，二者共用一个存储区，在此消彼长的过程中达到高效的内存使用。</li><li>代码区用来存储程序运行时的代码，也就是指令。</li><li>静态存储区一般用来存储程序运行中的静态数据和全局数据。</li><li>堆区的内存分配由程序员决定，在程序运行过程中，动态分配的内存就是堆中的内存。</li><li>栈区的内存分配由编译器决定，当寄存器数量不够的时候或者遇到数组、结构体等数据，编译器将他们存储到栈区，栈区还可用于换出寄存器的操作。</li></ul><h5 id="_1-栈区、过程帧：" tabindex="-1">1.栈区、过程帧： <a class="header-anchor" href="#_1-栈区、过程帧：" aria-hidden="true">#</a></h5><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98.png" alt=""></p><ul><li>我们现在假设栈为空，$sp 和 $fp指针都指向栈顶，现在我们push4个数据入栈，栈底存的是数据0，由于我们要存4个字节的数据，因此栈指针要给数据预留出四个字节。</li><li>$sp - 4，这样栈指针就到了新的栈顶的位置，随后把数据存入。</li><li>现在我们在内存中创建了一块栈区，帧指针指向栈底，栈指针指向栈顶，这两者之间的这一片栈空间我们叫做：过程帧，或者活动记录。</li></ul><h5 id="_2-大端寻址与小端寻址：" tabindex="-1">2.大端寻址与小端寻址： <a class="header-anchor" href="#_2-大端寻址与小端寻址：" aria-hidden="true">#</a></h5><ul><li>对于32位的机器来讲，每一次从内存中存储或取走的数据大多数都是一个字，那么字的地址是如何定义的呢，并且在这一个字中，四个字节又是怎么排列的呢，大端寻址和小端寻址就是来解决这一问题的。</li><li>大端寻址指的是，向内存中存储数据的时候，字中的低字节放在高地址，高字节放在低地址，小端寻址与其相反。</li><li>无论是大端寻址还是小端寻址，每一个字的地址与该字中的字节的低地址相同。</li></ul><h6 id="a-mips-32的大端寻址：" tabindex="-1">a.MIPS-32的大端寻址： <a class="header-anchor" href="#a-mips-32的大端寻址：" aria-hidden="true">#</a></h6><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt=""></p><h6 id="b-其他架构的小端寻址：" tabindex="-1">b.其他架构的小端寻址： <a class="header-anchor" href="#b-其他架构的小端寻址：" aria-hidden="true">#</a></h6><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E5%B0%8F%E7%AB%AF%E5%AF%BB%E5%9D%80.jpg" alt=""></p><h3 id="四、mips-32指令：" tabindex="-1">四、MIPS-32指令： <a class="header-anchor" href="#四、mips-32指令：" aria-hidden="true">#</a></h3><h4 id="_1-mips-32指令格式：" tabindex="-1">1.MIPS-32指令格式： <a class="header-anchor" href="#_1-mips-32指令格式：" aria-hidden="true">#</a></h4><ul><li>MIPS-32中的指令为定长指令，也就是对于任何一种确定指令，其指令的长度都为32位，也就是一个字，处理器一次正好能够处理一个指令。</li><li>MIPS-32中一共有三种指令格式：R型，I型，J型。</li></ul><h6 id="a-r型-寄存器类型-：" tabindex="-1">a.R型(寄存器类型)： <a class="header-anchor" href="#a-r型-寄存器类型-：" aria-hidden="true">#</a></h6><ul><li>R型指令的字段： <img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/R%E5%9E%8B%E6%8C%87%E4%BB%A4.png" alt=""></li><li>对于R类型指令，源操作数和目标操作数必须都是寄存器。</li></ul><h6 id="b-i型-立即数类型-：" tabindex="-1">b.I型(立即数类型)： <a class="header-anchor" href="#b-i型-立即数类型-：" aria-hidden="true">#</a></h6><ul><li>I型指令的字段： <img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/I%E5%9E%8B%E6%8C%87%E4%BB%A4.png" alt=""></li></ul><h6 id="c-j型-跳转类型-：" tabindex="-1">c.J型(跳转类型)： <a class="header-anchor" href="#c-j型-跳转类型-：" aria-hidden="true">#</a></h6><ul><li>J型指令的字段： <img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/J%E5%9E%8B%E6%8C%87%E4%BB%A4.png" alt=""></li></ul><h4 id="_2-运算指令：" tabindex="-1">2.运算指令： <a class="header-anchor" href="#_2-运算指令：" aria-hidden="true">#</a></h4><h6 id="add：" tabindex="-1">add： <a class="header-anchor" href="#add：" aria-hidden="true">#</a></h6><ul><li><code>add $t0 , $t1 , $t2</code>表示把寄存器t1和t2的值相加之后存入寄存器t0中。</li><li>该指令属于R类型指令。</li></ul><h6 id="sub：" tabindex="-1">sub： <a class="header-anchor" href="#sub：" aria-hidden="true">#</a></h6><ul><li><code>sub $t0 , $t1 , $t2</code>表示用寄存器t1的值减去寄存器t2的值，结果存入寄存器t0中。</li><li>该指令属于R类型指令。</li></ul><h6 id="addi：" tabindex="-1">addi： <a class="header-anchor" href="#addi：" aria-hidden="true">#</a></h6><ul><li><code>addi $t0 , $t1 , 0x2</code>表示把2这个立即数和寄存器t1中的值相加，存入寄存器t0中。</li><li>该指令属于I类型指令。</li><li>汇编指令中的立即数是不占用内存空间的。</li><li>一些注意事项： <ul><li>由于addi指令是i型指令，因此立即数的大小只有16位。</li><li>MIPS-32规定，这个立即数是有符号数，可正可负，当立即数为负数的时候，存储的编码为补码。</li><li>因此该立即数的范围是-32768 ~ 32767。</li></ul></li></ul><h6 id="and" tabindex="-1">and: <a class="header-anchor" href="#and" aria-hidden="true">#</a></h6><ul><li><code>and $t0 , $t1 , $t2</code>表示把寄存器t1的值和t2的值进行按位与操作，结果存入t0中。</li><li>该指令属于R类型指令。</li></ul><h6 id="or：" tabindex="-1">or： <a class="header-anchor" href="#or：" aria-hidden="true">#</a></h6><ul><li><code>or $t0 , $t1 , $t2</code>表示把寄存器t1的值和t2的值进行按位或操作，结果存入t0中。</li><li>该指令属于R类型指令。</li></ul><h6 id="nor或非：" tabindex="-1">nor或非： <a class="header-anchor" href="#nor或非：" aria-hidden="true">#</a></h6><ul><li><code>nor $t0 , $t1 , $t2</code>表示把寄存器t1的值和寄存器t2的值进行按位或非操作。</li><li>该指令属于R类型指令。</li><li>对于MIPS-32来讲，没有非(按位取反)指令。</li><li>我们知道，一个数与0做或运算的结果是这个数本身，那么再取非就是这个数按位取反的结果。</li><li>因此<code>nor $t0 , $t1 , $zero</code>这一条指令就实现了对寄存器t1按位取反，并将结果存入t0中。</li></ul><h6 id="andi：" tabindex="-1">andi： <a class="header-anchor" href="#andi：" aria-hidden="true">#</a></h6><ul><li><code>andi $t0 , $t1 , 0x2</code>表示把寄存器t1的值和立即数2进行按位与操作，结果存入t0中。</li><li>该指令为I型指令，因此有16bit用来存储立即数。</li><li>注意：MIPS-32要求这个立即数是无符号数，因此为正，取值范围是：0 ~ 65535。</li></ul><h6 id="ori：" tabindex="-1">ori： <a class="header-anchor" href="#ori：" aria-hidden="true">#</a></h6><ul><li><code>ori $t0 , $t1 , 0x2</code>表示把寄存器t1的值和立即数2进行按位或操作，结果存入t0中。</li><li>该指令为I型指令，因此有16bit用来存储立即数。</li><li>注意：MIPS-32要求这个立即数是无符号数，因此为正，取值范围是：0 ~ 65535。</li></ul><h6 id="sll：" tabindex="-1">sll： <a class="header-anchor" href="#sll：" aria-hidden="true">#</a></h6><ul><li><code>sll $t0 , $t1 , 0x3</code>表示把寄存器t1中的值左移3位，并把结果存放到寄存器t0中。</li><li>移位后右侧补0。</li><li>该指令为R型指令。</li><li>注意： <ul><li>对于移位运算符来讲，指令段rs(也就是第一个源操作数的位置)恒为0。</li><li>shamt段存储的是移位的个数，shamt段有5bit，因此移位空间是0 ~ 31。</li></ul></li><li>一个数在左移的时候，如果没有位数丢失，那么每一次左移都能相当于乘2。对于比较小的数，我们一般使用左移来乘2。</li></ul><h6 id="srl：" tabindex="-1">srl： <a class="header-anchor" href="#srl：" aria-hidden="true">#</a></h6><ul><li><code>srl $t0 , $t1 , 0x3</code>表示把寄存器t1中的数据右移3位，并把结果保存在寄存器t0中。</li><li>移位后左侧补0。</li><li>该指令为R型指令。</li><li>注意： <ul><li>对于移位运算符来讲，指令段rs(也就是第一个源操作数的位置)恒为0。</li><li>shamt段存储的是移位的个数，shamt段有5bit，因此移位空间是0 ~ 31。</li></ul></li></ul><h4 id="_3-数据传输指令：" tabindex="-1">3.数据传输指令： <a class="header-anchor" href="#_3-数据传输指令：" aria-hidden="true">#</a></h4><ul><li>数据传输指令用于数据在寄存器和内存之间进行交换。</li></ul><h6 id="lw-load-word" tabindex="-1">lw(load word): <a class="header-anchor" href="#lw-load-word" aria-hidden="true">#</a></h6><ul><li>取字指令，每次从内存中取出一个字(4byte)的数据放入寄存器中。</li><li><code>lw $t0 , 20($s0)</code>该指令从寄存器s0所存的地址上偏移20个字节，也就是从s0所存地址开始算起的第5个字上取出数据(4byte)，放入寄存器t0中。</li><li>偏移量以字节为单位，但是由于是取字，因此偏移量应该是4的整数倍。</li><li>该指令是I型指令。</li><li>指令段中的rs对应寄存器s0的编号；rt对应寄存器t0的编号，此时rt表示目标寄存器编号。</li></ul><h6 id="sw-store-word-：" tabindex="-1">sw(store word)： <a class="header-anchor" href="#sw-store-word-：" aria-hidden="true">#</a></h6><ul><li>存字指令，把寄存器中的数据存入内存中。</li><li><code>sw $t0 , 20($s0)</code>该指令把寄存器t0中的值，存入以寄存器s0所存的地址为基地址，偏移20个字节的位置。</li><li>偏移量以字节为单位，但是由于是存字，因此偏移量应该是4的整数倍。</li><li>该指令是I型指令。</li><li>指令段中的rs对应寄存器t0的编号；rt对应寄存器s0的编号，此时rt表示目标寄存器编号。注意与lw的指令段区分。</li></ul><h5 id="a-符号扩展：" tabindex="-1">a.符号扩展： <a class="header-anchor" href="#a-符号扩展：" aria-hidden="true">#</a></h5><h6 id="lh-load-half-：" tabindex="-1">lh(load half)： <a class="header-anchor" href="#lh-load-half-：" aria-hidden="true">#</a></h6><ul><li>为了方便，我们这里只说明取半字、无符号取半字、存半字。</li><li>我们要注意，这里的半字指的是一个字中的低半字，对于取字节来讲，取的也是最小端的字节，而不是说对应哪个字节就取哪个字节。</li><li><code>lh $t0 , 0($s0)</code>这条指令表示在寄存器s0所存的地址上，取这个字的低半字，放入寄存器$t0中。</li><li>放入寄存器的时候按照有符号的形式放入，如果低半字的最高位是1，那么认为是负数，则放入寄存器的时候，寄存器的高16位被扩展成1，相反被扩展成0。</li><li>该指令属于I型指令。</li></ul><h6 id="lhu-load-half-unsigned-：" tabindex="-1">lhu(load half unsigned)： <a class="header-anchor" href="#lhu-load-half-unsigned-：" aria-hidden="true">#</a></h6><ul><li>无符号取半字<code>lhu $t0 , 0($s0)</code>这条指令表示在寄存器s0所在的地址上，取这个字的低半字，以无符号的形式放入寄存器$t0中，也就是寄存器的高16位被扩展成0。</li><li>该指令属于I型指令。</li></ul><h6 id="sh-store-half-：" tabindex="-1">sh(store half)： <a class="header-anchor" href="#sh-store-half-：" aria-hidden="true">#</a></h6><ul><li><code>sh $t0 , 0($s0)</code>这条指令表示把寄存器t0中的低半字，存入寄存器s0所存地址中。</li><li>注意，该指令默认以无符号的形式存储，存入内存目标字的低半字，高半字全部为0。</li></ul><h5 id="b-装载32位立即数：" tabindex="-1">b.装载32位立即数： <a class="header-anchor" href="#b-装载32位立即数：" aria-hidden="true">#</a></h5><ul><li>使用addi指令处理的立即数范围是：-32768 ~ 32767，因此将32位立即数存入寄存器中还需要其他指令。</li></ul><h6 id="lui：" tabindex="-1">lui： <a class="header-anchor" href="#lui：" aria-hidden="true">#</a></h6><ul><li><code>lui $t0 , 0xffff</code>表示将立即数0xffff存入寄存器t0的高16位上，同时把寄存器t0的底16位初始化为0。</li><li>该指令为I型指令，因此立即数的范围是0 ~ 0xffff。</li></ul><h6 id="ori：-1" tabindex="-1">ori： <a class="header-anchor" href="#ori：-1" aria-hidden="true">#</a></h6><ul><li><code>ori $t0 , $t0 , 0xffff</code>表示将立即数0xffff与寄存器t0的值进行或运算，由于这个立即数最大为0xffff，并且寄存器t0的底16位全部为0，因此就相当于在没有影响t0高16位的情况下，把0xffff放到了寄存器t0的低16位上。</li></ul><h6 id="装载成功：" tabindex="-1">装载成功： <a class="header-anchor" href="#装载成功：" aria-hidden="true">#</a></h6><ul><li>这两个指令同时使用，就把0xffffffff这个32位立即数存储到了寄存器t0中。</li></ul><h4 id="_4-跳转指令：" tabindex="-1">4.跳转指令： <a class="header-anchor" href="#_4-跳转指令：" aria-hidden="true">#</a></h4><h5 id="a-标签：" tabindex="-1">a.标签： <a class="header-anchor" href="#a-标签：" aria-hidden="true">#</a></h5><ul><li>在汇编语言中，标签就相是过程名，一个标签代表着一个地址，使用跳转指令跳转到标签上就能够从标签处开始继续执行指令。</li></ul><h6 id="beq-branch-if-equal-：" tabindex="-1">beq(branch if equal)： <a class="header-anchor" href="#beq-branch-if-equal-：" aria-hidden="true">#</a></h6><ul><li>相等则分支，<code>beq $t0 , $t1 , Branch</code>如果寄存器t0和寄存器t1的值相等，则程序跳转到Branch这个标签处，从Branch开始继续执行。</li><li>该指令是I型指令。</li></ul><h6 id="bne-branch-if-not-equal-：" tabindex="-1">bne(branch if not equal)： <a class="header-anchor" href="#bne-branch-if-not-equal-：" aria-hidden="true">#</a></h6><ul><li>不等则分支，<code>bne $t0 , $t1 , Branch</code>如果寄存器t0和寄存器t1的值不等，则程序跳转到Branch这个标签处，从Branch开始继续执行。</li><li>该指令是I型执行。</li></ul><h6 id="slt-set-on-less-than-：" tabindex="-1">slt(set on less than)： <a class="header-anchor" href="#slt-set-on-less-than-：" aria-hidden="true">#</a></h6><ul><li>我们先来了解一下什么是置位和复位，在计算机中，我们把一个信号设置为1就叫做置位，把一个信号设置为0就叫做复位。</li><li>小于则置位，<code>slt $t0 , $t1 , $t2</code>如果寄存器t1小于寄存器t2，那么寄存器t0被置位“1”，否则被复位“0”。</li><li>该指令为R类型指令。</li><li>这里我们要注意，slt指令把两个源操作寄存器中的值当成有符号数进行处理。</li></ul><h6 id="slti-立即数版本-：" tabindex="-1">slti(立即数版本)： <a class="header-anchor" href="#slti-立即数版本-：" aria-hidden="true">#</a></h6><ul><li>和slt指令的用法相同，是I类型指令。</li><li>由于立即数被当做有符号数，因此立即数的范围是-32768 ~ 32767。</li></ul><h6 id="sltu-unsigned版本-：" tabindex="-1">sltu(unsigned版本)： <a class="header-anchor" href="#sltu-unsigned版本-：" aria-hidden="true">#</a></h6><ul><li>和slt指令的用法相同，是R型指令。</li><li>该指令把源操作寄存器中的数当成无符号类型。</li></ul><h6 id="j-jump-：" tabindex="-1">j(jump)： <a class="header-anchor" href="#j-jump-：" aria-hidden="true">#</a></h6><ul><li>无条件跳转指令，<code>j Branch</code>表示直接跳到Branch标签处。</li><li>该指令为J型指令。</li></ul><h5 id="b-if-else语句：" tabindex="-1">b.if-else语句： <a class="header-anchor" href="#b-if-else语句：" aria-hidden="true">#</a></h5><ul><li>通过上面四类指令的组合，我们可以完成所有if-lse语句的翻译。</li></ul><h6 id="_1-判断条件为-“-”的if-else语句：" tabindex="-1">1.判断条件为 “ == ”的if-else语句： <a class="header-anchor" href="#_1-判断条件为-“-”的if-else语句：" aria-hidden="true">#</a></h6><div class="language-cpp"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">i </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> j</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">else</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//这里，我们把i，j的值放入寄存器：$s0 , $1</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//f，g，h的值放入寄存器：$t0 , $t1 , $t2</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//我们先来观察一下这个if-else，当i == g的时候，则执行if语句，否则执行else语句，因此else语句相当于分支。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//因此，我们的分支语句应该用bnf，branch if not equal。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//MIPS汇编：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">bnf $s1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $s2 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Else #如果i不等于j，则切换到分支Else</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">add $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 #如果i等于j，则执行加法</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">j Exit #这里我们为了避免顺序执行Else分支，因此使用一个jump跳转到Exit，Exit标签不需要内容</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">Else: </span></span>
<span class="line"><span style="color:#A6ACCD;">sub $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 #Else标签，执行减法操作</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">Exit：#退出标签。</span></span>
<span class="line"></span></code></pre></div><h6 id="_2-判断条件为-“-”的if-else语句：" tabindex="-1">2.判断条件为 “ != ”的if-else语句： <a class="header-anchor" href="#_2-判断条件为-“-”的if-else语句：" aria-hidden="true">#</a></h6><div class="language-cpp"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">i </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> j</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">else</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//由于相等条件是跳转分支，因此使用beq</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//MIPS汇编:</span></span>
<span class="line"><span style="color:#A6ACCD;">beq $s0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $s1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Else </span></span>
<span class="line"><span style="color:#A6ACCD;">add $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 </span></span>
<span class="line"><span style="color:#A6ACCD;">j Exit </span></span>
<span class="line"><span style="color:#A6ACCD;">Else: </span></span>
<span class="line"><span style="color:#A6ACCD;">sub $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 </span></span>
<span class="line"><span style="color:#A6ACCD;">Exit: </span></span>
<span class="line"></span></code></pre></div><h6 id="_3-判断条件为-“-”的if-else语句：" tabindex="-1">3.判断条件为 “ &lt; ”的if-else语句： <a class="header-anchor" href="#_3-判断条件为-“-”的if-else语句：" aria-hidden="true">#</a></h6><div class="language-cpp"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> j</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">else</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//这里我们需要用到小于则置位。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//这里的分支条件是不小于，也就是复位跳转。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//MIPS汇编：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">slt $t3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $s0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $s1 </span></span>
<span class="line"><span style="color:#A6ACCD;">#如果i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> j，则t3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">，因此下面的跳转不成立，顺序执行，如果条件不成立，则t3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">，下面的跳转成立，接下来会执行Else分支。</span></span>
<span class="line"><span style="color:#A6ACCD;">beq $t3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Else </span></span>
<span class="line"><span style="color:#A6ACCD;">add $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 </span></span>
<span class="line"><span style="color:#A6ACCD;">j Exit </span></span>
<span class="line"><span style="color:#A6ACCD;">#为了避免if</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">else全都执行，使用jump跳转指令。</span></span>
<span class="line"><span style="color:#A6ACCD;">Else: </span></span>
<span class="line"><span style="color:#A6ACCD;">sub $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 </span></span>
<span class="line"><span style="color:#A6ACCD;">Exit: </span></span>
<span class="line"></span></code></pre></div><ul><li>判断&gt;条件的时候只需要把beq分支跳转改成bne分支跳转即可。</li></ul><h6 id="_4-判断条件为-“-”的if-else语句：" tabindex="-1">4.判断条件为 “ &lt; ”的if-else语句： <a class="header-anchor" href="#_4-判断条件为-“-”的if-else语句：" aria-hidden="true">#</a></h6><div class="language-cpp"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">i </span><span style="color:#89DDFF;">&lt;=</span><span style="color:#A6ACCD;"> j</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">else</span></span>
<span class="line"><span style="color:#A6ACCD;">	f </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//这里我们需要使用小于则置位。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//注意，相等的条件同样需要判断。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//MIPS汇编：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">slt $t3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $s0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $s1 </span></span>
<span class="line"><span style="color:#A6ACCD;">#如果i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> j</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">则t3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">，并且下面的跳转不成立，因此执行If分支；如果t3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">，则跳转到Else，注意，t3等于0的时候，可能是由i </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> j引起的，因此我们还需要在Else分支中检测一次，使用一个相等则跳转指令。</span></span>
<span class="line"><span style="color:#A6ACCD;">beq $t3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Else </span></span>
<span class="line"><span style="color:#A6ACCD;">If: </span></span>
<span class="line"><span style="color:#A6ACCD;">add $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 </span></span>
<span class="line"><span style="color:#A6ACCD;">j Exit </span></span>
<span class="line"><span style="color:#A6ACCD;">#为了避免if</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">else全都执行，使用jump跳转指令。</span></span>
<span class="line"><span style="color:#A6ACCD;">Else: </span></span>
<span class="line"><span style="color:#A6ACCD;">beq $s0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $s1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> If </span></span>
<span class="line"><span style="color:#A6ACCD;">sub $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 </span></span>
<span class="line"><span style="color:#A6ACCD;">Exit: </span></span>
<span class="line"></span></code></pre></div><ul><li>判断&gt;=条件的时候只需要把第一个beq分支跳转改成bne分支跳转即可。</li></ul><h5 id="c-数组下标越界检验：" tabindex="-1">c.数组下标越界检验： <a class="header-anchor" href="#c-数组下标越界检验：" aria-hidden="true">#</a></h5><ul><li>可以使用sltu对数组下标是否越界进行检验。</li><li>检验思想如下： <ul><li>假设数组下标的循环变量是t0，数组大小为t1。</li><li>越界的两种情况：1.数组下标循环变量t0小于0，第二种情况，数组下标循环变量t0大于t1。</li><li>对于两个寄存器中的数据，如果t0是负数，那么其最高位一定是1，此时可以利用sltu来判断，t0会恒大于t1的值。</li><li>如果两个寄存器中的数都为正数，那么当t0大于t1的时候也是越界。</li></ul></li><li>因此我们使用一条sltu加一条跳转指令就可以完成该操作。</li></ul><div class="language-cpp"><span class="copy"></span><pre><code><span class="line"><span style="color:#676E95;font-style:italic;">//MIPS汇编：</span></span>
<span class="line"><span style="color:#A6ACCD;">sltu $t2 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t0</span></span>
<span class="line"><span style="color:#A6ACCD;">#如果越界，那么t1中的值就会小于t0中的值，此时对t2进行置位操作，不跳转；如果没越界，那么t2为0，此时下一条条件分支语句会进行跳转。</span></span>
<span class="line"><span style="color:#A6ACCD;">beq $t2 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> IndexOutOfBounds</span></span>
<span class="line"><span style="color:#A6ACCD;">#跳转到标签IndexOutOfBounds处，该标签处可能会提供越界提示操作。</span></span>
<span class="line"></span></code></pre></div><h5 id="d-过程调用中的跳转和链接指令：" tabindex="-1">d.过程调用中的跳转和链接指令： <a class="header-anchor" href="#d-过程调用中的跳转和链接指令：" aria-hidden="true">#</a></h5><ul><li>对于C语言中的函数调用，调用的时候主函数把控制权交给被调函数，调用结束后程序再回到主函数中执行下一条语句。</li><li>在汇编语言中，使用跳转和链接指令来执行过程。</li></ul><h6 id="jal：" tabindex="-1">jal： <a class="header-anchor" href="#jal：" aria-hidden="true">#</a></h6><ul><li><code>jal Branch</code>表示把下一条指令的地址存入寄存器$ra，然后跳转到标签Branch的位置开始执行该过程。</li></ul><h6 id="jr：" tabindex="-1">jr： <a class="header-anchor" href="#jr：" aria-hidden="true">#</a></h6><ul><li><code>jr $ra</code>表示直接跳转到寄存器ra中存储的地址的位置。</li><li>因此我们可以发现，将jal和jr两条指令连用就实现了过程调用。</li></ul><h5 id="e-叶过程的执行：" tabindex="-1">e.叶过程的执行： <a class="header-anchor" href="#e-叶过程的执行：" aria-hidden="true">#</a></h5><ul><li>在汇编语言中，调用一个过程就相当于执行分支跳转。</li><li>在C语言中，需要向函数传递参数，因此在汇编中也同样存在这个问题。</li><li>$a0 ~ $a3这四个寄存器用来存放向过程传递的参数， $v0 ~ $v1这两个寄存器存放过程的返回值。</li><li>下面用MIPS汇编实现一个数组清零操作：</li></ul><div class="language-cpp"><span class="copy"></span><pre><code><span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">clear</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> a</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> size</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> size </span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span></span>
<span class="line"><span style="color:#A6ACCD;">		a</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//假设数组a的基地址存在寄存器a0中，参数size存在寄存器a1中。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//将变量i存在寄存器t0中。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//MIPS汇编代码：</span></span>
<span class="line"><span style="color:#A6ACCD;">move $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero</span></span>
<span class="line"><span style="color:#A6ACCD;">#首先把变量i初始化为0，使用一条伪指令move</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">Loop:#开始进入循环</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">slt $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $a1 </span></span>
<span class="line"><span style="color:#A6ACCD;">#首先比较变量i和数组大小size的值，小于则满足循环，置位并且执行下面的这条分支语句；否则说明不进入循环，也就是跳转会主程序的下一条指令处，通过读取jr指令实现。</span></span>
<span class="line"><span style="color:#A6ACCD;">bne $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Clear </span></span>
<span class="line"><span style="color:#A6ACCD;">jr $ra #退出循环的话那么就返回主程序的下一条指令。</span></span>
<span class="line"><span style="color:#A6ACCD;">Clear: #开始进入数组清零过程</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">sll $t2 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0x2</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">#首先把i的值左移两位，这样相当于对i乘4</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">因为int数组每个元素占一个字的大小，所以每次移动4字节寻址</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">，并且把这个临时值存在t2中。</span></span>
<span class="line"><span style="color:#A6ACCD;">add $t3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t2 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $a0 </span></span>
<span class="line"><span style="color:#A6ACCD;">#把偏移量t2和基地址a0相加，获取a</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">的地址。</span></span>
<span class="line"><span style="color:#A6ACCD;">sw $zero </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">$t3</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">#将a</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">清零。</span></span>
<span class="line"><span style="color:#A6ACCD;">addi $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0x1</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">#这里对变量i进行自增加操作</span></span>
<span class="line"><span style="color:#A6ACCD;">j Loop #继续跳转回标签Loop，执行下一次循环。</span></span>
<span class="line"></span></code></pre></div><h5 id="f-嵌套过程的执行：" tabindex="-1">f.嵌套过程的执行： <a class="header-anchor" href="#f-嵌套过程的执行：" aria-hidden="true">#</a></h5><ul><li>由于嵌套调用过程，因此需要对寄存器$ra进行换出操作。</li><li>下面用MIPS实现一个求平方和操作：</li></ul><div class="language-cpp"><span class="copy"></span><pre><code><span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sum_of_squares</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> a</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> size</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> sum </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> size </span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span></span>
<span class="line"><span style="color:#A6ACCD;">		sum </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">square</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> sum</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">square</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> a</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> a</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//假设数组a的基地址存在寄存器a0中，参数size存在寄存器a1中,向square函数中传递的参数放入寄存器a3中。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//将变量sum存在寄存器t0中，将变量i存在寄存器t1中。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//MIPS汇编：</span></span>
<span class="line"><span style="color:#A6ACCD;">move $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero</span></span>
<span class="line"><span style="color:#A6ACCD;">move $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero</span></span>
<span class="line"><span style="color:#A6ACCD;">#上述两条指令将变量sum和i进行初始化0操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">Loop:</span></span>
<span class="line"><span style="color:#A6ACCD;">slt $t2 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $a1</span></span>
<span class="line"><span style="color:#A6ACCD;">#如果i的值小于size的值，则置位，并且执行循环，否则返回sum的值，并且返回到主程序的下一条指令。</span></span>
<span class="line"><span style="color:#A6ACCD;">bne $t2 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $zero </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Sum</span></span>
<span class="line"><span style="color:#A6ACCD;">#t2不等于，则执行循环中的Sum操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">move $v0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t0</span></span>
<span class="line"><span style="color:#A6ACCD;">addi $sp </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $sp </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0x4</span></span>
<span class="line"><span style="color:#A6ACCD;">lw $ra </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">$sp</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">jr $ra</span></span>
<span class="line"><span style="color:#A6ACCD;">#上面四条指令完成的是跳出循环之后的操作：</span></span>
<span class="line"><span style="color:#A6ACCD;">#首先，将返回值sum放入返回值寄存器v0；</span></span>
<span class="line"><span style="color:#A6ACCD;">#其次，由于调用过其他函数，因此ra寄存器中的内容进行过换出，此时在调用sum_of_squares这个过程中创建的栈中，只有一个主程序的地址了，因此将栈指针上移一个字，然后把这个地址取到ra中。</span></span>
<span class="line"><span style="color:#A6ACCD;">#最后，使用jr跳转回主程序的下一条指令。</span></span>
<span class="line"><span style="color:#A6ACCD;">Sum:</span></span>
<span class="line"><span style="color:#A6ACCD;">sll $t3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0x2</span></span>
<span class="line"><span style="color:#A6ACCD;">add $t4 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $a0</span></span>
<span class="line"><span style="color:#A6ACCD;">#上面两条语句获得了a</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">的地址，存在t4中。</span></span>
<span class="line"><span style="color:#A6ACCD;">lw $a3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">$t4</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">addi $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0x1</span></span>
<span class="line"><span style="color:#A6ACCD;">#上面两条语句将a</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">读了出来，并且写入寄存器a3中，作为参数。</span></span>
<span class="line"><span style="color:#A6ACCD;">#变量i的值自增加。</span></span>
<span class="line"><span style="color:#A6ACCD;">addi $sp </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $sp </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">0x4</span></span>
<span class="line"><span style="color:#A6ACCD;">sw $ra </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">$sp</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//上述两条指令完成了一个换出寄存器的操作，由于接下来ra的值要被使用，因此要把此时ra的值存入栈中。</span></span>
<span class="line"><span style="color:#A6ACCD;">jal Square</span></span>
<span class="line"><span style="color:#A6ACCD;">#跳转并链接，此时ra存放的是下面add这条指令的地址。</span></span>
<span class="line"><span style="color:#A6ACCD;">add $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $t0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $v0</span></span>
<span class="line"><span style="color:#A6ACCD;">j Loop #Sum过程执行完毕，此时跳回Loop，再次执行循环。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">Square:</span></span>
<span class="line"><span style="color:#A6ACCD;">mult $v0 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $a3 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $a3</span></span>
<span class="line"><span style="color:#A6ACCD;">jr $ra</span></span>
<span class="line"></span></code></pre></div><h5 id="g-伪指令：" tabindex="-1">g.伪指令： <a class="header-anchor" href="#g-伪指令：" aria-hidden="true">#</a></h5><ul><li>MIPS-32提供了很多伪指令，处理器只能读懂普通指令，不能读懂伪指令。</li><li>伪指令可以减少汇编代码，在写汇编程序的时候推荐使用，伪指令本质上就是一些普通指令的组合。</li><li>汇编器能够读懂伪指令，将伪指令转换为普通指令，然后交给处理器执行。</li></ul><h6 id="常见伪指令：" tabindex="-1">常见伪指令： <a class="header-anchor" href="#常见伪指令：" aria-hidden="true">#</a></h6><ul><li><code>move $t0 , $t1</code>把寄存器t1的值复制到寄存器t0中。</li><li><code>mult $t0 , $t1 , $t2</code>把寄存器t1的值和寄存器t2的值相乘后放入寄存器t0中。</li></ul><h3 id="五、mips-32寻址方式：" tabindex="-1">五、MIPS-32寻址方式： <a class="header-anchor" href="#五、mips-32寻址方式：" aria-hidden="true">#</a></h3><h5 id="_1-寄存器寻址：" tabindex="-1">1.寄存器寻址： <a class="header-anchor" href="#_1-寄存器寻址：" aria-hidden="true">#</a></h5><ul><li>寄存器寻址最为简单，所有的R型指令都采用寄存器寻址的方式，CPU通过寄存器的编号来找到相应的寄存器。</li></ul><h5 id="_2-立即数寻址：" tabindex="-1">2.立即数寻址： <a class="header-anchor" href="#_2-立即数寻址：" aria-hidden="true">#</a></h5><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80.png" alt=""></p><ul><li>立即数寻址指的就是I型指令中的立即数指令，立即数直接作为指令中的常数，不需要在存储器中进行寻找。</li></ul><h5 id="_3-基地址寻址：" tabindex="-1">3.基地址寻址： <a class="header-anchor" href="#_3-基地址寻址：" aria-hidden="true">#</a></h5><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt=""></p><ul><li>对于I型指令，在其中一个寄存器中存储内存中的某一个基地址，然后把16位立即数作为在该基地址上的偏移量，从而实现寻址，I指令后面的16位立即数能够覆盖的存储空间为：- $2^{15}$ ~ $2^{15} - 1$ (byte)，大约是64KB。</li><li>由于这个寻址空间比较小，因此很多时候我们都把这个立即数符号扩展成32位，再与一个寄存器相加，得到的值作为偏移量。 <ul><li>为什么要符号扩展？因为这样可以表示：-$2^{31}$ ~ $2^{31} - 1$(byte)，大约是4GB。</li></ul></li><li>lw、sw等执行内存和寄存器交换的指令都使用基地址寻址，即一个寄存器存储内存中的某一段空间的基址。</li></ul><h5 id="_4-pc相对寻址：" tabindex="-1">4.PC相对寻址： <a class="header-anchor" href="#_4-pc相对寻址：" aria-hidden="true">#</a></h5><ul><li>为了扩大寻址空间，有一些指令的便宜量不是以字节为单位，而是以字为单位。</li><li>我们首先来了解一下PC，PC在MIPS-32中不是通用寄存器，PC中存储的是处理器当前运行指令的地址。</li><li>PC相对寻址指的是从PC的下一条指令开始寻址，注意此时是把PC + 4作为寻址的基址，偏移量还是16位的立即数，但是这个16位的立即数是以字为单位的，偏移1位相当于字节中偏移4位，因此对应字节有18位(左移两位表示乘4)。</li><li>此时的寻址空间大小：-$2^{17}$ ~ $2^{17} - 1$ ,大约是128KB。</li><li>条件分支指令通常都使用PC相对寻址。 <code>bne $t0 , $t1 , 2500</code>表示的是跳转到PC+4+4x2500这个地址处。因此指令中的这个偏移量就是以字为单位的。</li><li>我们可以认为PC寻址的基础是基地址寻址。</li></ul><h5 id="_5-伪直接寻址：" tabindex="-1">5.伪直接寻址： <a class="header-anchor" href="#_5-伪直接寻址：" aria-hidden="true">#</a></h5><p><img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/%E4%BC%AA%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt=""></p><ul><li>J型指令的操作位是6位，地址位是26位，伪直接寻址指的是把J型指令中的26位与PC中的高4位进行拼接操作。</li><li>如何拼接？ <ul><li>我们把J指令中的地址位当成“字”地址，那么一共可以表示$2^{26}$个字的大小空间。</li><li>这$2^{26}$个字正好对应这$2^{28}$个字节。</li><li>把这26位左移两位(无符号左移，补0)，然后与PC高四位拼接。</li><li>之后这个地址就可以表示与PC高4位相同的所有地址了。</li><li>寻址空间：$2^{28}$byte，大约256MB。</li></ul></li></ul><h6 id="疑问解答：" tabindex="-1">疑问解答： <a class="header-anchor" href="#疑问解答：" aria-hidden="true">#</a></h6><ul><li>对于拼接的32位地址，只有26位是可变的，为什么能代表$2^{28}$byte呢？ <ul><li>实际上，如果这26位代表的是字节，那么确实只能寻址64MB，但是我们规定这26位表示的是字，26bit+00已经能够表示$2^{26}$个字的地址，这些字能够对应上$2^{28}$byte，而不是说我完全得到这么多个字节地址，我只需要直到所在的字就可以了。</li><li>并且，我们在指令后面加的数字也是表示的字地址。<code>j 2500</code>表示跳转到10000字节处，很显然有些字节地址我们是无法得到的，但却覆盖了这么多字节。</li></ul></li></ul><h3 id="六、原子操作-atomic-operation-：" tabindex="-1">六、原子操作(atomic operation)： <a class="header-anchor" href="#六、原子操作-atomic-operation-：" aria-hidden="true">#</a></h3><h4 id="_1-数据竞争：" tabindex="-1">1.数据竞争： <a class="header-anchor" href="#_1-数据竞争：" aria-hidden="true">#</a></h4><ul><li>计算机要不停的执行数以万计的指令，虽然每个CPU一次只能执行一条指令，但是对于多核心计算机来说，一次能够执行很多指令。</li><li>当某个指令在内存中写的结果是另外一个指令在内存中要读的结果的时候，此时，读取必须发生在写入之后，否则就发生了数据竞争。</li></ul><h4 id="_2-原子操作：" tabindex="-1">2.原子操作： <a class="header-anchor" href="#_2-原子操作：" aria-hidden="true">#</a></h4><ul><li>为了解决数据竞争的问题，计算机指令中的普通指令(一条不能化简的指令)全都是原子指令，也就是原子操作。</li><li>原子取的是物理学中的原子，我们认为原子不能再分(当然现在不成立了)，对于一个原子操作，其他线程无法看到该原子操作的中途内容，即把这个操作当成一个执行的最小单位。</li><li>为什么这么做，因为不论什么操作指令，再执行的时候都是有时间和步骤的，尽管这很快。</li></ul><h4 id="_3-指令对形成原子操作、互斥区：" tabindex="-1">3.指令对形成原子操作、互斥区： <a class="header-anchor" href="#_3-指令对形成原子操作、互斥区：" aria-hidden="true">#</a></h4><ul><li>有些时候我们希望较复杂的操作也是原子的，即不可分割的，但是多条原子指令组合在一起很大程度上就会产生数据竞争(非原子性)。</li><li>这时，我们引入了指令对和互斥区的概念： <ul><li>指令对：我们把一对指令当成一个原子操作。</li><li>互斥区：在原子操作中，被唯一处理器(其他处理器无法操作)操作的内存叫互斥区。</li><li>当执行起始指令的时候，使用存储器中的某个单元表示一个锁变量(互斥区)，如果该锁变量的值为0，表示该锁变量为解锁状态，此时该原子操作能够操作该互斥区，并把锁变量变为1，即加锁，执行完原子操作的结束指令的时候，对锁变量进行释放，即解锁。</li></ul></li></ul><h3 id="六、c语言程序的编译过程：" tabindex="-1">六、C语言程序的编译过程： <a class="header-anchor" href="#六、c语言程序的编译过程：" aria-hidden="true">#</a></h3><ul><li>第一步：通过编译器，将高级语言文件(.c)翻译成汇编语言文件(.asm)。</li><li>第二步：通过汇编器，首先把伪指令替换为等价的真正指令，再将汇编语言翻译成机器语言目标文件(.obj)。</li><li>第三步：通过链接器把目标文件、静态链接库(.lib)、动态链接库拼接成可执行文件(.dll)。</li><li>第四步：通过加载器将可执行文件(.exe)加载到内存。</li></ul><h3 id="七、处理器发展史：" tabindex="-1">七、处理器发展史： <a class="header-anchor" href="#七、处理器发展史：" aria-hidden="true">#</a></h3><h5 id="_1-x86：" tabindex="-1">1.x86： <a class="header-anchor" href="#_1-x86：" aria-hidden="true">#</a></h5><ul><li>x86：8086，16bit指令集架构。</li><li>x86：80386,32bit指令集架构，是所有架构中最早升级到32bit的。</li></ul><h5 id="_2-arm：" tabindex="-1">2.ARM： <a class="header-anchor" href="#_2-arm：" aria-hidden="true">#</a></h5><ul><li>ARMv7，32bit指令集。</li><li>ARMv8，64bit指令集，更接近MIPS架构。</li></ul></div></div></main><footer class="VPDocFooter" data-v-79ca2460 data-v-04568844><div class="edit-info" data-v-04568844><!----><!----></div><div class="prev-next" data-v-04568844><div class="pager" data-v-04568844><a class="pager-link prev" href="/hardware_group/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A6%82%E8%A6%81.html" data-v-04568844><span class="desc" data-v-04568844>Previous page</span><span class="title" data-v-04568844>计算机硬件概要</span></a></div><div class="has-prev pager" data-v-04568844><a class="pager-link next" href="/hardware_group/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97.html" data-v-04568844><span class="desc" data-v-04568844>Next page</span><span class="title" data-v-04568844>计算机的算术运算</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-6b5fd0a9 data-v-5b331722><div class="container" data-v-5b331722><p class="message" data-v-5b331722>Released under the MIT License.</p><p class="copyright" data-v-5b331722>Copyright © 2023-present CCNU-IOT</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"introduction_index.md\":\"1f9af9e1\",\"app_group_index.md\":\"7e605a86\",\"hardware_group_51单片机_b.led灯点亮以及延时.md\":\"3f861ad1\",\"hardware_group_51单片机_c.独立按键操控led开关和蜂鸣器开关.md\":\"0d80abaa\",\"hardware_group_51单片机_d.独立按键控制led流水灯.md\":\"81055033\",\"hardware_group_51单片机_e.静态点亮数码管.md\":\"e39d16fa\",\"hardware_group_51单片机_f.动态点亮数码管.md\":\"b8d8612b\",\"hardware_group_51单片机_g.矩阵键盘.md\":\"1c5aba3d\",\"hardware_group_51单片机_h.中断系统.md\":\"2ba2c5f8\",\"hardware_group_51单片机_i.定时器与计数器.md\":\"54bf63df\",\"hardware_group_51单片机_j.pwm脉宽调制信号的发生与控制.md\":\"6186efa9\",\"hardware_group_51单片机_k.串口通信的原理与应用.md\":\"775e2580\",\"hardware_group_51单片机_l.ds18b20数字温度计.md\":\"e0c3e3ee\",\"hardware_group_51单片机_m.ds1302实时时钟.md\":\"4f9a84d0\",\"hardware_group_51单片机_n.at24c02.md\":\"3e303f11\",\"hardware_group_51单片机_o.pcf8591.md\":\"3c842cd2\",\"hardware_group_51单片机_p.超声波测距模块.md\":\"c146b4e1\",\"hardware_group_51单片机_开发板原理图.md\":\"52db073d\",\"hardware_group_51单片机_开发板注意事项.md\":\"a8e0fa89\",\"hardware_group_index.md\":\"8827873e\",\"hardware_group_第一次培训_git快速入门.md\":\"0ad44f2d\",\"hardware_group_第一次培训_linux虚拟机的安装和卸载.md\":\"ed4d5aa0\",\"hardware_group_计算机组成与设计_mips架构处理器设计.md\":\"071891a9\",\"hardware_group_计算机组成与设计_计算机的算术运算.md\":\"c5cb7861\",\"hardware_group_计算机组成与设计_计算机的语言.md\":\"c8e1d064\",\"hardware_group_计算机组成与设计_计算机硬件概要.md\":\"1b27b1f6\",\"index.md\":\"9199f74b\",\"software_group_index.md\":\"3dc88b3d\",\"software_group_算法和数据结构_单链表.md\":\"5686ed93\"}")</script>
    <script type="module" async src="/assets/app.9eab122d.js"></script>
    
  </body>
</html>